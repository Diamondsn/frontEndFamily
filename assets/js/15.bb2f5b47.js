(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{412:function(t,_,r){"use strict";r.r(_);var v=r(56),a=Object(v.a)({},(function(){var t=this,_=t.$createElement,r=t._self._c||_;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"操作系统"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#操作系统"}},[t._v("#")]),t._v(" 操作系统")]),t._v(" "),r("h2",{attrs:{id:"进程与线程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#进程与线程"}},[t._v("#")]),t._v(" 进程与线程")]),t._v(" "),r("ol",[r("li",[t._v("线程可提高程序的并发执行，可提高系统效率")]),t._v(" "),r("li",[t._v("一个线程可创建多个线程")]),t._v(" "),r("li",[t._v("线程间可使用信号量来实现同步")]),t._v(" "),r("li",[t._v("操作系统内核可调度内核级线程、进程，不能调度用户级线程")])]),t._v(" "),r("h2",{attrs:{id:"管道"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#管道"}},[t._v("#")]),t._v(" 管道")]),t._v(" "),r("p",[t._v("管道是单向的、先进先出的，它把一个进程的输出和另一个进程的输入连接在一起，又称为pipe文件"),r("br"),t._v("\n一个进程（写进程）在管道的 尾部写入数据，另一个进程（读进程）从管道的头部读出数据"),r("br"),t._v("\n类似于通信中的半双工系统，可以双向传输，但同一时刻只能一个方向传输，不能两个方向同时进行"),r("br"),t._v("\n管道的容量通常为内存上的一页，所以不受磁盘限制"),r("br"),t._v("\n在管道满时，写进程阻塞，但管道空时，读进程阻塞。\n管道进程必须提供以下三方的协调能力")]),t._v(" "),r("ol",[r("li",[t._v("互斥：当一个进程正在对pipe进行读/写操作时，其它进程必须等待。")]),t._v(" "),r("li",[t._v("同步：当写进程把一定量数据写入pipe时，便去睡眠等待，直到读进程取走数据后，唤醒写进程。读进程读一空pipe时，也应该睡眠等待，直到写进程将数据写入管道，才将之唤醒。")]),t._v(" "),r("li",[t._v("确定对方是否存在，只有确定了对方已经存在时，才能进行通信。")])]),t._v(" "),r("h2",{attrs:{id:"分页存储"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#分页存储"}},[t._v("#")]),t._v(" 分页存储")]),t._v(" "),r("p",[t._v("分页存储管理系统使用到存储分配表和页表"),r("br"),t._v("\n页表，建立进程中的块（页）->  内存中的块（页框）的映射关系"),r("br"),t._v("\n存储分配表记录空闲块的信息")]),t._v(" "),r("h2",{attrs:{id:"测试"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#测试"}},[t._v("#")]),t._v(" 测试")]),t._v(" "),r("p",[t._v("单元测试的基本测试单元是模块"),r("br"),t._v("\n集成测试的基本测试单元是软件子系统和软件系统"),r("br"),t._v("\n系统测试的基本测试单元是软件系统")]),t._v(" "),r("h2",{attrs:{id:"死锁"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#死锁"}},[t._v("#")]),t._v(" 死锁")]),t._v(" "),r("p",[r("a",{attrs:{href:"https://www.nowcoder.com/test/question/done?tid=49829431&qid=5630",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://www.nowcoder.com/test/question/done?tid=49829431&qid=5630"),r("OutboundLink")],1)]),t._v(" "),r("p",[t._v("死锁的必要条件:")]),t._v(" "),r("ol",[r("li",[t._v("互斥条件:指进程对所分配的资源进行排它性使用，也就是说在某一段时间内，某资源只被一个进程占用，如果还有其它进程请求该资源，则请求的进程只能等待，直到该资源被释放。")]),t._v(" "),r("li",[t._v("请求和保持条件:指一个进程已经拥有了某些资源,但是它还需要其它资源,于是又提出新的申请,而该资源又偏偏被其它进程占用,此时该申请资源的进程产生了阻塞, 它又不释放自己已占有的资源。")]),t._v(" "),r("li",[t._v("不剥夺条件:指进程已获得的资源不能被剥夺,只有自己使用完之后才释放.( 可见如果资源可被剥夺,该条就不成立,所以A错 )")]),t._v(" "),r("li",[t._v("环路等待条件:指发生死锁的时候,一定存在一个环路:进程1-资源2(被进程2占用)-资源3(被进程3占用).............-进程n-资源1(被进程1占用)")])]),t._v(" "),r("p",[t._v("竞争临时资源会产生死锁"),r("br"),t._v("\n如果进程在一次性申请其所需的全部资源成功后才运行，就不会发生死锁")])])}),[],!1,null,null,null);_.default=a.exports}}]);