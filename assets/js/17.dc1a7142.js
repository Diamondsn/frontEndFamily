(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{402:function(t,e,l){"use strict";l.r(e);var n=l(54),r=Object(n.a)({},(function(){var t=this,e=t.$createElement,l=t._self._c||e;return l("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[l("h1",{attrs:{id:"虚拟-dom-的优缺点"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#虚拟-dom-的优缺点"}},[t._v("#")]),t._v(" 虚拟 DOM 的优缺点")]),t._v(" "),l("p",[t._v("优点:")]),t._v(" "),l("ol",[l("li",[t._v("保证性能下限： 框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；")]),t._v(" "),l("li",[t._v("无需手动操作 DOM： 我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率；")]),t._v(" "),l("li",[t._v("跨平台： 虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等")])]),t._v(" "),l("p",[t._v("缺点:")]),t._v(" "),l("ol",[l("li",[t._v("无法进行极致优化： 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。")]),t._v(" "),l("li",[t._v("首次渲染大量DOM时，由于多了一层虚拟DOM的计算，会比innerHTML插入慢。")])])])}),[],!1,null,null,null);e.default=r.exports}}]);